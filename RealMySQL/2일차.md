# 4. 아키텍처

## 1. MySQL 엔진

- 커넥션 핸들러
    - 클라이언트로부터의 접속 및 쿼리 요청 처리
- SQL 파서 및 전 처리기
- 옵티마이저
    - 쿼리의 최적화된 실행

## 2. 스토리지 엔진

- 실제 데이터를 디스크 스토리지에 저장하거나, 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담
- MySQL 서버에서 엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 사용할 수 있음
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 버퍼 풀(InnoDB)과 같은 기능을 내장

## 3. 핸들러 API

- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는데, 이러한 요청을 `Handler` 요청이라 하고, 여기서 사용되는 `API`를 핸들러 API라 함
- 핸들러 API를 통해 얼마나 많은 데이터 작업이 있었는지 확인하기 위한 쿼리
    - `SHOW GLOBAL STATUS LIKE 'Handler%';`

## 4. MySQL 스레딩 구조

- MySQL은 프로세스 기반이 아닌 스레드 기반으로 작동
- 포그라운드 스레드
    - 최소 MySQL 서버에 접속된 클라이언트의 수만큼 존재
    - 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리
    - 작업이 끝나고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 `Thread cache`로 되돌아감
    - 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size`시스템 변수로 설정
- 백그라운드 스레드
    - MySQL 설정에 따라 가변적
    - 백그라운드 스레드 종류 (중요한건 강조 표시)
        - 인서트 버퍼를 병합하는 스레드
        - `로그를 디스크로 기록하는 스레드`
        - `InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드`
        - 데이터를 버퍼로 읽어 오는 스레드
        - 잠금이나 데드락을 모니터링하는 스레드
    
    → 쓰기 작업이 많을 경우 백그라운드로 처리하기 때문에 일반적인 내장 디스크를 사용할 때는 2~4개, DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정
    

## 5. 메모리 할당 및 사용 구조

- 글로벌 메모리 영역
    - MySQL 서버가 시작되면서 운영체제로부터 할당
    - 일반적으로 클라이언트 스레드 수와 무관하게 `하나의 메모리 공간` 할당
    - 모든 스레드끼리 공유 (N개 여도 공유 됨)
    - 대표적인 글로벌 메모리 영역
        - 테이블 캐시
        - InnoDB 버퍼 풀
        - InnoDB 어댑티브 해시 인덱스
        - InnoDB 리두 로그 버퍼
- 로컬 메모리 영역
    - 세션 메모리 영역
    - MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역
    - 각 클라이언트 스레드별로 독립적으로 할당 (절대 공유되어 사용되지 않음)
    - 대표적인 로컬 메모리 영역
        - 정렬 버퍼
        - 조인 버퍼
        - 바이너리 로그 캐시
        - 네트워크 버퍼

## 6. 플러그인 스토리지 엔진 모델

- MySQL 서버에서는 스토리지 엔진뿐만 아니라 다양한 기능을 플러그인 형태로 지원
- MySQL 서버의 기능을 커스텀하게 확장할 수 있는 플로그인 API가 공개되어 있어 완전히 새로운 기능을 플러그인을 이용해 구현 가능

## 7. 컴포넌트

- MySQL 8.0부터 기존 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처 지원
- 플러그인의 몇 가지 단점을 보완
    - 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리 통신 불가
    - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안 됨)
    - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화 어려움

## 8. 쿼리 실행 구조

- 쿼리 파서
    - 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 의미
- 전처리기
    - 파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인
- 옵티마이저
    - 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 결정하는 역하을 담당
    - DBMS의 두뇌에 해당
- 실행 엔진
    - 실행 엔진과 핸들러는 손과 발에 비유 가능
    - 회사로 비유하면 옵티마이저는 경영진, 실행 엔진은 중간 관리자, 핸들러는 각 업무의 실무자로 비유 가능
    - EX) 옵티마이저가 `GROUP BY`를 처리하기 위해 임시 테이블을 사용하기로 결정했다고 보자
        - 실행 엔진이 핸들러에게 임시 테이블을 만들라고 요청
        - 다시 실행 엔진은 `WHERE`절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
        - 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
        - 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터를 읽어 오라고 핸들러에게 다시 요청
        - 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
    
    → 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행
    
- 핸들러(스토리지 엔진)
    - MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당

## 9. 복제

뒤에서 다룰 내용

## 10. 쿼리 캐시

- 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당함
- SQL의 실행 결과를 메모리에 캐시하고, 동일한 SQL 쿼리가 실행되면 테이블을 읽지 않고, 즉시 결과를 반환
- `8.0`버전 부터 완전희 제거
    - 데이터 변경은 거의 없고 읽기만 하는 서비스에서 매우 유용하지만 흔치 않음
    - 수많은 버그의 원인으로 지목되는 경우가 많음

## 11. 스레드 풀

- 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다 하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소모를 줄이려는 것이 목적

## 12. 트랜잭션 지원 메타데이터

- `8.0`버전부터 테이블의 구조 정보나 스토어드 프로그램의 코드 관련 정보를 모두 InnoDB의 테이블에 저장하도록 개선
    - `5.7`버전까지는 테이블의 구조를 FRM 파일에 저장하고 일부 스토어드 프로그램 또한 파일 기반으로 관리하여 생성 및 변경 작업이 트랜잭션을 지원하지 않기 때문에 테이블의 생성 또는 변경 도중 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남는 문제가 있음